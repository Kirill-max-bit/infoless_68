# infoless_68
 
**ВОПРОС1: Рекурсия — это метод, при котором функция вызывает саму себя для решения подзадач. Примером рекурсивной функции является вычисление факториала числа:**

 **def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)**

**ВОПРОС2: Рекурсивное определение должно включать:Базовый случай — условие, при котором процесс завершается (например, факториал 0).Рекурсивный случай — часть, которая описывает, как функция вызывает саму себя для решения меньшей подзадачи.**

 
**ВОПРОС3: Рекурсивная процедура — это функция, которая вызывает саму себя, чтобы разделить задачу на более простые части и завершить решение, используя базовые случаи.**

**ВОПРОС4: Задача «Ханойские башни» заключается в перемещении дисков между тремя стержнями с соблюдением определённых правил. Алгоритм решения с использованием стека (не рекурсия) может выглядеть так:
Создайте стек для хранения состояний движений.
Имейте циклы, которые продолжат выполнение, пока не будут перемещены все диски.
Используйте циклы для манипуляций, аналогичных тем, что делают рекурсивные вызовы.**

**ВОПРОС5:Процедура Б содержит рекурсивный вызов самой себя. Процедура А не является рекурсивной, так как она не вызывает саму себя, а лишь вызывает процедуру Б.**

**ВОПРОС6: Рекурсия никогда не остановится, если базовый случай недостижим (например, функция всегда вызывает себя с тем же или более сложным аргументом). В рассматриваемых задачах базовые случаи предусмотрены, и они останавливают рекурсию.**

**ВОПРОС7: Стек — это структура данных, работающая по принципу LIFO (последний пришёл — первый вышел). Он используется для хранения информации о текущих состояниях выполнения функций, включая адрес возврата и локальные переменные.**

**ВОПРОС8: Переполнение стека происходит, когда глубина рекурсии превышает максимальный размер стека, обычно вызванная слишком многими рекурсивными вызовами (например, при отсутствии базового случая).**

**ВОПРОС9: Достоинства:**  

**Элегантность и простота кода для некоторых задач, таких как разбиение на подзадачи.
Недостатки:** 

**Потенциальное переполнение стека.**

**Обычно большая затратность по времени и памяти по сравнению с итеративными подходами.
Использовать рекурсию следует, когда задачи требуют деления на подзадачи, но избегать её для больших глубин рекурсии или задач, легко решаемых итеративными методами.**
